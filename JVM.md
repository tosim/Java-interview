# JVM

## Java代码运行流程
1. 编写java源文件
2. Java编译器编译Java代码
3. 生成.class字节码文件
4. 类加载器验证并加载.class文件
5. 被Java解释器解释执行，或者是被即时代码编译器有选择的转换成机器码执行
6. 进入运行期系统
7. 操作系统层
8. 硬件层

## Java实现平台无关的原理
1. java程序
2. Java Api 和 Java 标准拓展Api
3. Java 基类和 Java 标准拓展类
4. Java虚拟机
5. Java移植接口
6. 适配器和Java操作系统，其中适配器实现了依赖于具体平台的部分

JVM通过移植接口实现了程序与操作系统的分离，从而实现了平台无关性。移植接口由适配器和Java操作系统两部分组成，其中依赖具体平台的部分为适配器。

## JVM 内存管理与垃圾回收
1. 首先将class通过类加载器验证并加载
2. 加载后内存空间中为：方法区，堆区，栈区，本地方法栈

### 内存管理
#### 1.堆区
1. 用于存放对象的内存
2. Java7及以后的版本，字符串常量存放于堆中
3. 分为新生代（Eden空间，From Survivor空间，To Survivor空间），老年代
4. 线程共享，但是可以划分出多个线程私有的分配缓冲区（TLAB）
5. 创建过多对象会导致堆内存溢出

#### 2.栈区
1. 基础数据类型
2. 方法的形参
3. 引用数据类型，在栈中分配地址空间，指向堆中的对象
4. 线程私有
5. 递归调用层次太深会导致stackoverflow

注意区分使用new的数组和直接指定大小的数组创建的区别

#### 3.方法区
1. 存放类的方法代码
2. 存放static变量和final常量
3. 类加载信息
4. 永久代
5. 使用CGLib添加过多动态代理类会导致永久代内存溢出

#### 4.本地方法栈
1. 用于支持native方法的执行，保存了native方法调用时的栈信息
2. 防止垃圾回收清理正在被本地方法调用的对象

#### 5.程序计数器
1. 线程私有，指向当前线程所执行的字节码的的地址
2. 如果正在执行native方法，则计数器为空（Undefined）
3. 唯一一个没有规定任何OutOfMemory的区域

### Java常量池
[Java三种常量池参考连接](https://www.cnblogs.com/holos/p/6603379.html)  

1. 字符串常量池  
  在类加载完成后，在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中，在1.6之前是在方法区中，1.7是在堆中，1.8是在元数据区中（将方法区存放在本地内存中）

2. class文件常量池
  用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)
  字面量就是常量概念，如文本字符串、被声明为final的常量值等。  
  符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。
3. 运行时常量池
  当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中  
  class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用
### JVM 垃圾回收
#### 判断对象是否存活
1. 引用计数法
2. 可达性分析法

#### 引用类型
1. 强引用：用new创建，只要强引用存在，就不会被GC回收  
2. 软引用：用SoftReference实现，在内存快溢出时，列入第二次回收范围
3. 若引用：用WeakReference实现，只能存活到下一次GC
4. 虚引用：用PhantomReference实现，一般用于系统通知该对象被回收

#### 方法区的回收
1. 类的卸载：所有实例已被回收，ClassLoader已被回收，对应的java.lang.Class没有被引用

#### finalize的自救
如果在该方法中重新让对象被引用，则不会被GC回收

#### 垃圾收集算法
**1. 标记清除**  
将需要回收的对象进行标记，然后清除  
不足：标记和清除过程效率不高，产生大量的内存碎片

**2. 标记整理**
让所有存活对象都向一端移动，直接清理掉端边界的内存  

**3. 复制**  
将内存划分为等大的两块，每次只使用其中的一块，GC时将存活的对象移到另一块，然后清理内存  

**4. 分代**
新生代-复制
老年代-标记清除、标记整理

#### 垃圾收集器
收集器|串行/并行/并发|新生代/老生代|算法|目标|适用场景
-|-|-|-|-|-
Serial|串行|新生代|复制|响应速度优先|单CPU环境下的Client模式
Serial Old|串行|老年代|标记-整理|响应速度优先|单CPU环境下的Client模式、CMS的后备方案
ParNew|并行|新生代|复制|响应速度优先|多CPU环境时在Server模式下与CMS配合
Parallel Scavenge|并行|新生代|复制|吞吐量优先|在后台运算而不需要太多交互的任务
Parallel Old|并行|老年代|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务
CMS|并发|老年代|标记-清除|响应速度优先|集中在互联网站或B/S系统服务端上的Java应用
G1|并发|新生代/老年代|标记-整理、复制|响应速度优先|面向服务端应用、将来替换CMS

## Java代码编译和执行的整个过程
主要包含：**java源码编译机制**，**类加载机制**，**类执行机制**
### Java源码编译机制
#### 编译过程
1. 分析和输入到符号表
2. 注解处理
3. 语义分析和生成class文件

#### class文件包含：  
1. 结构信息：包括class文件格式版本号及各部分的数量与大小的信息
2. 元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池
3. 方法信息：对应Java源码中语句和表达式对应的信息。

### Java类加载机制
#### 类加载过程：
1. 加载  
通过类的全限定名获取字节流，转化为方法区的运行时存储结构，在内存中生成Class对象。  

2. 验证  
文件格式验证，元数据验证，字节码教研，符号引用验证

3. 准备  
被static修饰的变量进行0值初始化  

4. 解析  
将常量池的符号引用替换为直接引用
5. 初始化  
执行构造器
6. 使用
7. 卸载

#### ①Bootstrap ClassLoader

负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

#### ②Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

#### ③App ClassLoader

负责记载classpath中指定的jar包及目录中class

#### ④Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader


#### 检查和加载顺序
加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

### Java类执行机制
JVM为每个新创建的线程都分配一个堆栈，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。
