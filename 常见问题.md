# 常见问题

## 1.java虚拟机内存模型
### 内存管理
#### 1.堆区
1. 用于存放对象的内存
2. Java7及以后的版本，字符串常量存放于堆中
3. 分为新生代（Eden空间，From Survivor空间，To Survivor空间），老年代
4. 线程共享，但是可以划分出多个线程私有的分配缓冲区（TLAB）
5. 创建过多对象会导致堆内存溢出

#### 2.栈区
1. 基础数据类型
2. 方法的形参
3. 引用数据类型，在栈中分配地址空间，指向堆中的对象
4. 线程私有
5. 递归调用层次太深会导致stackoverflow

注意区分使用new的数组和直接指定大小的数组创建的区别

#### 3.方法区
1. 存放类的方法代码
2. 存放static变量和final常量
3. 类加载信息
4. 永久代
5. 使用CGLib添加过多动态代理类会导致永久代内存溢出

#### 4.本地方法栈
1. 用于支持native方法的执行，保存了native方法调用时的栈信息
2. 防止垃圾回收清理正在被本地方法调用的对象

#### 5.程序计数器
1. 线程私有，指向当前线程所执行的字节码的的地址
2. 如果正在执行native方法，则计数器为空（Undefined）
3. 唯一一个没有规定任何OutOfMemory的区域

## 2.内存溢出一般发生在哪个区，永久代会发生内存溢出吗？
### 1. 内存溢出一般发生的情况有： 
#### 1. 堆中分配过多的对象
#### 2. 依赖的类过多，方法区内存溢出

## 3. 动态加载类的框架了解哪些？
#### ①Bootstrap ClassLoader

负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

#### ②Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

#### ③App ClassLoader

负责记载classpath中指定的jar包及目录中class

#### ④Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader


#### 检查和加载顺序
加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

## 4. 动态代理一般有哪几种方式？动态代理的应用场景？
### 1. 动态代理的方式
1. jdk代理，被代理类需要实现某个接口
2. cgLib代理
3. aspectj代理

### 2. 动态代理的应用场景
(1)设计模式中有一个开闭原则，对修改关闭，在工作中接手前人的代码式，可以通过代理对类进行增强。

(2)我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑。

(3)Spring的AOP机制就是采用动态代理的机制来实现切面编程。


## 5. 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？
1. 栈会溢出，StackOverFlowExection，OutOfMemoryExection
2. jvm在命令行下暂时修改参数，catalina.sh 或 catalina.bat中永久修改参数
3. 在我的电脑上是 -Xss< size>

## 6. 用过哪些命令查看jvm的状态、堆栈信息？
1. jps、jstack、jmap、jhat、jstat

## 7. jvm的垃圾回收机制？
#### 判断对象是否存活
1. 引用计数法
2. 可达性分析法

#### 引用类型
1. 强引用：用new创建，只要强引用存在，就不会被GC回收  
2. 软引用：用SoftReference实现，在内存快溢出时，列入第二次回收范围
3. 弱引用：用WeakReference实现，只能存活到下一次GC
4. 虚引用：用PhantomReference实现，一般用于系统通知该对象被回收

#### 方法区的回收
1. 类的卸载：所有实例已被回收，ClassLoader已被回收，对应的java.lang.Class没有被引用

#### finalize的自救
如果在该方法中重新让对象被引用，则不会被GC回收

#### 垃圾收集算法
**1. 标记清除**  
将需要回收的对象进行标记，然后清除  
不足：标记和清除过程效率不高，产生大量的内存碎片

**2. 标记整理**
让所有存活对象都向一端移动，直接清理掉端边界的内存  

**3. 复制**  
将内存划分为等大的两块，每次只使用其中的一块，GC时将存活的对象移到另一块，然后清理内存  

**4. 分代**
新生代-复制
老年代-标记清除、标记整理

#### 垃圾收集器
收集器|串行/并行/并发|新生代/老生代|算法|目标|适用场景
-|-|-|-|-|-
Serial|串行|新生代|复制|响应速度优先|单CPU环境下的Client模式
Serial Old|串行|老年代|标记-整理|响应速度优先|单CPU环境下的Client模式、CMS的后备方案
ParNew|并行|新生代|复制|响应速度优先|多CPU环境时在Server模式下与CMS配合
Parallel Scavenge|并行|新生代|复制|吞吐量优先|在后台运算而不需要太多交互的任务
Parallel Old|并行|老年代|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务
CMS|并发|老年代|标记-清除|响应速度优先|集中在互联网站或B/S系统服务端上的Java应用
G1|并发|新生代/老年代|标记-整理、复制|响应速度优先|面向服务端应用、将来替换CMS

## 8. java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？
### 类加载机制
#### 类加载过程：
1. 加载  
通过类的全限定名获取字节流，转化为方法区的运行时存储结构，在内存中生成Class对象。  

2. 验证  
文件格式验证，元数据验证，字节码教研，符号引用验证

3. 准备  
被static修饰的变量进行0值初始化  

4. 解析  
将常量池的符号引用替换为直接引用
5. 初始化  
执行构造器
6. 使用
7. 卸载

#### ①Bootstrap ClassLoader

负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

#### ②Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

#### ③App ClassLoader

负责记载classpath中指定的jar包及目录中class

#### ④Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

#### 检查和加载顺序
加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

#### 自定义的ClassLoader通过继承java.lang.ClassLoader来实现，也可以使用URLClassLoader更简单。

#### 使用findClass()能保证不会违背双亲委派模式，因为loadClass()实现了双亲委派机制，会调用findClass()




















