# 数据库

## 事务的隔离级别

### 事务并发带来的问题

***1. 丢失修改***  
事务A和事务B同时对同一数据进行修改的时候，若事务B后完成，会将事务A的修改覆盖掉  
  
***2. 读脏数据***  
事务A对数据D进行修改，同时事务B读取数据D，事务B可能会读到事务A修改后的数据，而此时事务A执行失败导致回滚，事务B读到的数据就是“脏数据”    

***3. 不可重复读***  
 * 事务A读取数据D，同时事务B修改数据D，事务A再次读取数据D，得到两次读取的数据不一致
 * 事务A读取数据D，同时事务B添加或删除了符合事务A查询条件的数据，事务A再次读取数据D，两次读取的数据个数不一致，也叫“幻读”
 
 
### 事务的隔离级别

***1. Read uncommitted 读未提交数据***  
能解决丢失修改的问题，但不能解决读脏数据和不可重复读

***2. Read committed 读提交数据***  
能解决丢失修改和读脏数据，但是不能解决不可重复读

***3. Repeated Read 可重复读***  
能解决丢失修改、读脏数据和不可重复读中的第一种情况，不能解决“幻读”

***4. Serializable 串行化***  
不并发当然啥问题都没有，按照顺序执行事务中的命令

### 事务隔离级别的实现

***一级封锁协议***  
在事务修改数据之前获取X锁(写锁)，在事务结束之后释放  
实现***Read uncommitted***

***二级封锁协议***  
满足一级封锁协议的前提下，在事务读数据之前，获取S锁（读锁），读完之后释放S锁，事务结束之后释放X锁  
实现***Read committed 读提交数据***

***三级封锁协议***  
满足一级封锁协议的前提下，在事务读数据之前，获取S锁，等事务结束之后释放S锁和X锁
实现***Repeated Read 可重复读***
